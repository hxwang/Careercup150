## Trees and Graphs

- 4.0 [[DFS, BFS]](../code/4.0.java)

- 4.1 Implement a function to check if a binary tree is balanced. For the purposes of this question, a balanced tree is defined to bea tree such that the heights of the two subtrees of any node never differ by more than one. [[Solution]](../code/4.1.java)

- 4.2 Given a directed graph, design an algorithm to find out whether there is a route between two nodes? [[Solution]](../code/4.2.java)

- 4.3 Given a sorted (increasing order) array, write an algorithm to create a binary search tree with minimal height. [[Solution]](../code/4.3.java)

- 4.4. Given a binary tree, design an algorithm which creates a linkedlist of all the nodes at each depth (e.g., if you have a tree with depth D, you will have D linkedlist). [[Solution]](../code/4.4.java)

- 4.5 Implement a function to check if a binary tree is a binary search tree. [[Solution]](../code/4.5.java)

- 4.6 Write an algorithm to find the "next" node (i.e., in-order successor) of a given node in a binary search tree. You may assume that each node has a link to its parent. [[Solution]](../code/4.6.java)

- 4.7 Design an algorithm and write code to find out the first common ancestor of two nodes in a binary tree. Avoid storing additional nodes in a data structure. NOTE: This is not necessarily a binary search tree. [[Solution]](../code/4.7.java)

- 4.8 You have two very large binary trees: T1m with millions of nodes, and T2, with hundreds of nodes. Create an algorithm to decide if T2 is a subtree of T1.
A tree R2 is a subtree of T2 if here exists a node n in T1 such that the subtree of n is identical to T2. That is, if you cut off the tree at node n, the two trees would be identical. [[Solution]](../code/4.8.java)

- 4.9 You are given a binary tre in which each node contains a value. Design an algorithm to print all paths which sum up to a given value. Note that a path can start or end anyware in the tree. [[Solution]](../code/4.9.java)
